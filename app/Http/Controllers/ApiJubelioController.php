<?php

namespace App\Http\Controllers;

use App\Models\Item;
use App\Models\Jubeliosync;
use App\Models\Logjubelio;
use Carbon\Carbon;
use Illuminate\Http\Request;

class ApiJubelioController extends Controller
{
    public function order(Request $request){
        $secret = 'corenation2025';
        $content = trim($request->getContent());

        $sign = hash_hmac('sha256',$content . $secret, $secret, false);

        $signature = $request->header('Sign');

        if ($signature !== $sign) {
            return response()->json(['error' => 'Invalid signature'], 403);
        }

        $dataApi = $request->all(); 

        $dataJubelio = [];

        if($dataApi['status'] == "SHIPPED"){

            $jubelioSync = Jubeliosync::where('jubelio_store_id',$dataApi['store_id'])->where('jubelio_store_id',$dataApi['location_id'])->first();

            if($jubelioSync){

                // $produkIds = collect($dataApi['items'])->pluck('item_code')->unique(); // Hilangkan duplikasi ID
                $itemCodes = collect($dataApi['items'])->pluck('item_code')->unique();

                // Ambil hanya kolom yang diperlukan
                $existingProducts = Item::whereIn('code', $itemCodes)
                    ->get(['id', 'code', 'name'])
                    ->keyBy('code'); // Index berdasarkan 'code' agar pencarian lebih cepat
                
                // Proses matching dengan map agar lebih efisien
                $groupedData = collect($dataApi['items'])->partition(fn($item) => isset($existingProducts[$item['item_code']]));
                
                $matched = $groupedData[0]->map(fn($item) => [
                    'itemId'   => $existingProducts[$item['item_code']]->id,
                    'code'     => $existingProducts[$item['item_code']]->code,
                    'name'     => $existingProducts[$item['item_code']]->name,
                    'quantity' => $item['qty'],
                    'price'    => $item['price'],
                    'discount' => $item['disc_amount'],
                    'subtotal' => $item['amount'],
                ])->values(); // Reset indeks array
                
                $notMatched = $groupedData[1]->values(); // Reset indeks array

                if($matched->count() > 0){

                    $dataJubelio = [
                        "date" => Carbon::now()->toDateString(),
                        "due" => null,
                        "warehouse" => $jubelioSync->warehouse_id,
                        "customer" => $jubelioSync->customer_id,
                        "invoice" => $dataApi['salesorder_no'],
                        "note" => "generated by jubelio",
                        "account" => "7204",
                        "amount" => null,
                        "addMoreInputFields" => $matched,
                        "disc" => "0",
                        "adjustment" => "0",
                        "ongkir" => "0"
                    ];

                }

               

            }

           

        }


     

        // $data = new Logjubelio();

        // $data->log = $request->items;

        // $data->save();

        $signature = $request->header('Sign');
        

       

        return response()->json([
            'status' => 'ok',
            'total_matched' => $matched->count(),
            'total_not_matched' => $notMatched->count(),
            'signature' => $signature,
            'data' => $dataJubelio
        ], 200);
    }

    public function retur(Request $request){
        $secret = 'corenation2025';
        $content = trim($request->getContent());

        $sign = hash_hmac('sha256',$content . $secret, $secret, false);

        $signature = $request->header('Sign');

        // $data = new Logjubelio();

        // $data->log = $request->items;

        // $data->save();

        $data = $request->all(); 

        return response()->json([
            'status' => 'ok',
            'signature' => $signature,
            'received_data' => $data
        ], 200);
    }
}
