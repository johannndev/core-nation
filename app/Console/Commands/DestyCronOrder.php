<?php

namespace App\Console\Commands;

use App\Exceptions\ModelException;
use App\Helpers\InvoiceTrackerHelpers;
use App\Helpers\StatManagerHelper;
use App\Models\Customer;
use App\Models\DestyPayload;
use App\Models\DestyWarehouse;
use App\Models\Item;
use App\Models\Transaction;
use Illuminate\Console\Command;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;

class DestyCronOrder extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'desty:cron-order';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Command description';

    /**
     * Execute the console command.
     */
    public function handle()
    {
        //
        Log::info('Desty Task dijalankan pada: ' . now());

        // 1. Ambil data pending
        $desty = DestyPayload::where('order_status_list', 'Completed')
            ->where('status', 'pending')
            ->orderBy('date', 'asc')
            ->first();

        if (!$desty) {
            Log::info("Tidak ada data untuk diproses");
            return;
        }

        // 2. LOCK MANUAL: update status menjadi "processing"
        //    hanya worker pertama yg dapat update === mencegah race condition.
        $updated = DestyPayload::where('id', $desty->id)
            ->where('status', 'pending') // pastikan masih pending
            ->update([
                'status' => 'processing',
                'info'   => 'Sedang diproses...'
            ]);

        if ($updated == 0) {
            // artinya worker lain sudah mengambil lebih dulu
            Log::info("Dilewati karena sudah diproses oleh worker lain: ID {$desty->id}");
            return;
        }

        // --- lanjut proses karena worker ini yang menang race ---

        $destyWh = DestyWarehouse::with('destySync')
            ->where('platform_warehouse_id', $desty->platform_warehouse_id)
            ->where('store_id', $desty->store_id)
            ->first();

        if (!$destyWh || !$destyWh->destySync) {
            DestyPayload::where('id', $desty->id)
                ->update(['status' => 'failed', 'info' => 'Desty Warehouse tidak ditemukan atau belum disync']);
            return;
        }


        // ==========================================
        // MATCHING ITEM (kode kamu, aman dari race)
        // ==========================================

        $itemCodes = collect($desty->item_list)->pluck('code')->unique();
        $existingProducts = Item::whereIn('code', $itemCodes)->get(['id', 'code', 'name'])->keyBy('code');

        $groupedData = collect($desty->item_list)->partition(
            fn($item) =>
            isset($existingProducts[$item['code']])
        );

        $matched = $groupedData[0]->map(fn($item) => [
            'itemId'   => $existingProducts[$item['code']]->id,
            'code'     => $existingProducts[$item['code']]->code,
            'name'     => $existingProducts[$item['code']]->name,
            'quantity' => $item['quantity'],
            'price'    => $item['price'],
            'discount' => 0,
            'subtotal' => $item['quantity'] * $item['price'],
        ])->values();

        $notMatched = $groupedData[1]->values();


        // 3. Jika ada item tidak ditemukan → gagal
        if ($notMatched->count() > 0) {

            $item_codes = array_column($notMatched->toArray(), 'code');
            $notMatchedString = implode(", ", $item_codes);

            DestyPayload::where('id', $desty->id)
                ->update(['status' => 'failed', 'info' => 'Item tidak ditemukan: ' . $notMatchedString]);

            return;
        }


        // 4. Cek apakah transaksi sudah ada → cegah duplikasi
        $cekTransaksi = Transaction::where('type', Transaction::TYPE_SELL)
            ->where('invoice', $desty->invoice)
            ->first();

        if ($cekTransaksi) {
            DestyPayload::where('id', $desty->id)
                ->update(['status' => 'processed', 'info' => 'Order duplicate, sudah dibuat sebelumnya']);
            return;
        }


        // ==========================================
        // BUAT TRANSAKSI BARU
        // ==========================================

        $dataOrder = [
            "date" => now()->toDateString(),
            "due" => null,
            "warehouse" => $destyWh->destySync->warehouse_id,
            "customer"  => $destyWh->destySync->customer_id,
            "invoice"   => $desty->invoice,
            "note"      => "generated by desty cron order",
            "account"   => "7204",
            "amount"    => null,
            "paid"      => null,
            "addMoreInputFields" => $matched,
            "disc"      => "0",
            "adjustment" => $desty->adjustment,
            "ongkir"    => "0"
        ];

        $dataCollect = (object)$dataOrder;

        $createData = $this->createTransaction(Transaction::TYPE_SELL, $dataCollect);

        if ($createData['status'] == "200") {
            DestyPayload::where('id', $desty->id)
                ->update(['status' => 'processed', 'info' => 'Order berhasil dibuat di sistem.']);
        } else {
            DestyPayload::where('id', $desty->id)
                ->update(['status' => 'error', 'info' => 'Gagal membuat order: ' . $createData['message']]);
        }
    }

    protected function createTransaction($type = null, $dataJubelio)
    {

        $maxRetries = 5; // Jumlah maksimal percobaan
        $attempts = 0;



        try {

            $class = array();

            DB::statement('SET TRANSACTION ISOLATION LEVEL READ COMMITTED');

            //start transaction
            DB::beginTransaction();

            $customer = Customer::find($dataJubelio->customer);
            $warehouse = Customer::find($dataJubelio->warehouse);

            // dd($customer,$warehouse);

            // $input = $dataJubelio;
            $transaction = new Transaction();
            $transaction->date = $dataJubelio->date;
            $transaction->type = $type;
            $transaction->adjustment     = $dataJubelio->adjustment;
            $transaction->user_id = -100;
            $transaction->submit_type = 2;
            $transaction->description = $dataJubelio->description ?? '';

            $transaction->invoice = $dataJubelio->invoice;

            if ($dataJubelio->due) {
                $transaction->due = $dataJubelio->due;
            } else {
                $transaction->due = '0000-00-00';
            }

            $transaction->detail_ids = ' ';

            $transaction->save();
            switch ($type) {
                case Transaction::TYPE_BUY:
                case Transaction::TYPE_RETURN:
                    $transaction->sender_id = $customer->id;
                    $transaction->receiver_id = $warehouse->id;
                    break;
                case Transaction::TYPE_SELL:
                case Transaction::TYPE_RETURN_SUPPLIER:
                    $transaction->sender_id = $warehouse->id;
                    $transaction->receiver_id = $customer->id;
                    break;
                default: //don't update stats for move, production
                    break;
            }

            $transaction->init($type);

            // dd($dataJubelio->addMoreInputFields);
            //gets the transaction id
            if (!$transaction->save())


                throw new ModelException($transaction->getErrors(), __LINE__);

            if (!$details = $transaction->createDetails($dataJubelio->addMoreInputFields))
                throw new ModelException($transaction->getErrors(), __LINE__);


            //check ppn first
            $transaction->checkPPN($transaction->sender, $transaction->receiver);




            //add to customer stat
            // $sm = new StatManager;

            $sm = new StatManagerHelper();
            switch ($type) {
                case Transaction::TYPE_BUY:
                case Transaction::TYPE_RETURN:
                    //add balance to sender(supplier)
                    $sender_balance = $sm->add($transaction->sender_id, $transaction, true); //skip 1 because the transaction is already created?
                    if ($sender_balance === false)
                        throw new ModelException($sm->getErrors());

                    $transaction->sender_balance = $sender_balance;
                    break;
                case Transaction::TYPE_SELL:
                case Transaction::TYPE_RETURN_SUPPLIER:
                    $transaction->setAttribute('total', 0 - $transaction->total); //make negative

                    //deduct balance from receiver(customer)
                    $receiver_balance = $sm->deduct($transaction->receiver_id, $transaction, true);
                    if ($receiver_balance === false)
                        throw new ModelException($sm->getErrors());

                    $transaction->receiver_balance = $receiver_balance;

                    // $transaction->save();

                    // dd($receiver_balance,$transaction, $transaction->receiver_balance);
                    break;
                default: //don't update stats for move, production
                    break;
            }



            if (!$transaction->save())
                throw new $transaction->getErrors();





            InvoiceTrackerHelpers::flag($transaction);


            if ($type == Transaction::TYPE_SELL || $type == Transaction::TYPE_RETURN) {



                // Query
                $result = DB::table('transaction_details')
                    ->where('transaction_details.transaction_id', $transaction->id)
                    ->join('items', 'transaction_details.item_id', '=', 'items.id')
                    ->whereIn('transaction_details.transaction_type', [Transaction::TYPE_SELL, Transaction::TYPE_RETURN]) // Filter transaction_type 2 dan 15
                    ->selectRaw('
                    items.group_id,
                    MONTH(transaction_details.date) as bulan,
                    YEAR(transaction_details.date) as tahun,
                    transaction_details.sender_id,
                    transaction_details.transaction_type,
                    SUM(transaction_details.quantity) as sum_qty,
                    SUM(transaction_details.total) as sum_total
                ')
                    ->groupBy('items.group_id', DB::raw('MONTH(transaction_details.date)'), DB::raw('YEAR(transaction_details.date)'), 'transaction_details.sender_id', 'transaction_details.transaction_type')
                    ->orderBy('items.group_id') // Optional: Untuk urutan hasil
                    ->sharedLock()
                    ->get();

                $insertData = [];
                foreach ($result as $row) {
                    $insertData[] = [
                        'group_id' => $row->group_id,
                        'bulan' => $row->bulan,
                        'tahun' => $row->tahun,
                        'sender_id' => $row->sender_id,
                        'type' => $row->transaction_type,
                        'sum_qty' => (int)$row->sum_qty,
                        'sum_total' => (int)$row->sum_total,
                        'created_at' => now(),
                        'updated_at' => now(),
                    ];
                }

                // dd($insertData);

                $this->updateOrCreateStatsalesOptimized($insertData);
            }

            //commit db transaction
            DB::commit();

            // $dataJubelio->session()->flash('success', 'Transaction # ' . $transaction->id. ' created.');

            return $data = [
                'status' => '200',
                'message' => 'ok',
                'transaction_id' => $transaction->id,
            ];

            //    return redirect()->route('transaction.getDetail',$transaction->id)->with('success', 'Transaction # ' . $transaction->id. ' created.');

            // return response()->json([
            //     'url' => route('transaction.getDetail',$transaction->id,$transaction->date),
            // ]);

        } catch (ModelException $e) {

            DB::rollBack();

            if ($e->getCode() == 1213) {

                return $data = [
                    'status' => '500',
                    'message' => $e->getMessage(),
                ];
            }

            return $data = [
                'status' => '422',
                'message' => $e->getErrors()['error'][0],
            ];


            // return response()->json($e->getErrors(), 500);

        } catch (\Exception $e) {
            DB::rollBack();

            return $data = [
                'status' => '422',
                'message' => $e->getMessage(),
            ];

            //    return redirect()->back()->withInput()->with('errorMessage',$e->getMessage());

            // return response()->json($e->getMessage(), 500);

        }
    }

    public function updateOrCreateStatsalesOptimized(array $data)
    {
        foreach ($data as $entry) {
            $existing = DB::table('stat_sells')
                ->where('group_id', $entry['group_id'])
                ->where('bulan', $entry['bulan'])
                ->where('tahun', $entry['tahun'])
                ->where('sender_id', $entry['sender_id'])
                ->sharedLock()
                ->first();

            if ($existing) {
                // Jika data ditemukan, update sum_qty dan sum_total
                DB::table('stat_sells')
                    ->where('id', $existing->id)
                    ->incrementEach([
                        'sum_qty' => $entry['sum_qty'],
                        'sum_total' => $entry['sum_total']
                    ]);
            } else {
                // Jika tidak ditemukan, insert data baru
                DB::table('stat_sells')->insert([
                    'group_id' => $entry['group_id'],
                    'bulan' => $entry['bulan'],
                    'tahun' => $entry['tahun'],
                    'sender_id' => $entry['sender_id'],
                    'type' => $entry['type'],
                    'sum_qty' => $entry['sum_qty'],
                    'sum_total' => $entry['sum_total'],
                    'created_at' => now(),
                    'updated_at' => now(),
                ]);
            }
        }

        return response()->json(['message' => 'Data processed successfully'], 200);
    }
}
